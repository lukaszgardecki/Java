type: edu
custom_name: stage5
files:
- name: src/correcter/Main.java
  visible: true
  text: |
    package correcter;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
  learner_created: false
- name: test/CorrecterTest.java
  visible: false
  text: |+
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.TestCase;

    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;

    class TestClue {
        String input;
        String fileContent;

        TestClue(String input, String fileContent) {
            this.input = input;
            this.fileContent = fileContent;
        }
    }

    public class CorrecterTest extends StageTest<TestClue> {

        private static File received = null;
        private static File encoded = null;
        private static File decoded = null;

        @Override
        public List<TestCase<TestClue>> generate() {
            TestClue[] testClues = new TestClue[]{
                new TestClue("encode", "Eat more of these french buns!"),
                new TestClue("send",   "Eat more of these french buns!"),
                new TestClue("decode", "Eat more of these french buns!"),

                new TestClue("encode", "$ome rand0m messAge"),
                new TestClue("send",   "$ome rand0m messAge"),
                new TestClue("decode", "$ome rand0m messAge"),

                new TestClue("encode", "better call Saul 555-00-73!"),
                new TestClue("send",   "better call Saul 555-00-73!"),
                new TestClue("decode", "better call Saul 555-00-73!"),

                new TestClue("encode", "5548172 6548 225147 23656595 5155"),
                new TestClue("send",   "5548172 6548 225147 23656595 5155"),
                new TestClue("decode", "5548172 6548 225147 23656595 5155"),
            };

            List<TestCase<TestClue>> result = new ArrayList<>();

            for (int i = 0; i < testClues.length; i++) {
                result.add(new TestCase<TestClue>()
                    .setAttach(testClues[i])
                    .setInput(testClues[i].input)
                    .addFile("send.txt", testClues[i].fileContent));
            }

            return result;
        }

        @Override
        public CheckResult check(String reply, TestClue clue) {
            String path = System.getProperty("user.dir");

            received = null;
            encoded = null;
            decoded = null;

            searchReceived();
            searchEncoded();
            searchDecoded();

            String correctFileBinary = toBinary(clue.fileContent.getBytes());
            String correctFileEncoded = encodeFile(correctFileBinary);

            String action = clue.input;

            if (action.equals("encode")) {

                if (encoded == null) {
                    return new CheckResult(false,
                        "Can't find encoded.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                byte[] encodedContent;
                FileInputStream encodedStream;

                try {
                    encodedStream = new FileInputStream(encoded);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    encodedContent = encodedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String encodedBinary = toBinary(encodedContent);

                return new CheckResult(encodedBinary.equals(correctFileEncoded));
            }

            if (action.equals("send")) {

                if (received == null) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it " +
                            "down or make sure the name of file is correct.");
                }

                byte[] receivedContent;

                FileInputStream receivedStream;

                try {
                    receivedStream = new FileInputStream(received);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    receivedContent = receivedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String receivedBinary = toBinary(receivedContent);


                return checkDifference(receivedBinary, correctFileEncoded);
            }



            if (action.equals("decode")) {

                if (decoded == null) {
                    return new CheckResult(false,
                        "Can't find decoded.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                byte[] decodedContent;


                FileInputStream decodedStream;

                try {
                    decodedStream = new FileInputStream(decoded);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    decodedContent = decodedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String decodedBinary = toBinary(decodedContent);

                if (!decodedBinary.equals(correctFileBinary)) {
                    return new CheckResult(false, "The decoded text must match initial text!");
                }

                return CheckResult.correct();
            }

            throw new RuntimeException("Can't check the program");
        }

        private static String toBinary(byte[] bytes) {
            StringBuilder sb = new StringBuilder(bytes.length * Byte.SIZE);
            for (int i = 0; i < Byte.SIZE * bytes.length; i++) {
                sb.append((bytes[i / Byte.SIZE] << i % Byte.SIZE & 0x80) == 0 ? '0' : '1');
            }
            return sb.toString();
        }

        private static byte[] fromBinary(String s) {
            int sLen = s.length();
            byte[] toReturn = new byte[(sLen + Byte.SIZE - 1) / Byte.SIZE];
            char c;
            for (int i = 0; i < sLen; i++)
                if ((c = s.charAt(i)) == '1')
                    toReturn[i / Byte.SIZE] = (byte) (toReturn[i / Byte.SIZE] | (0x80 >>> (i % Byte.SIZE)));
                else if (c != '0')
                    throw new IllegalArgumentException();
            return toReturn;
        }

        private static void searchReceived() {
            File file = new File("received.txt");
            if (file.exists()) {
                received = file;
            }
        }

        private static void searchEncoded() {
            File file = new File("encoded.txt");
            if (file.exists()) {
                encoded = file;
            }
        }

        private static void searchDecoded() {
            File file = new File("decoded.txt");
            if (file.exists()) {
                decoded = file;
            }
        }

        private String encodeFile(String binaryString) {

            String encoded = "";

            for (int i = 0; i < binaryString.length(); i += 4) {

                if (i + 4 > binaryString.length()) {
                    throw new RuntimeException("Can't decode binary data");
                }

                int startSubIndex = i;
                int stopSubIndex = i + 4;

                String currSub = binaryString.substring(startSubIndex, stopSubIndex);

                String encodedPart;

                int parityBit1 = 0;
                int parityBit2 = 0;
                int parityBit4 = 0;

                if (currSub.charAt(0) == '1') {
                    parityBit1++;
                    parityBit2++;
                }

                if (currSub.charAt(1) == '1') {
                    parityBit1++;
                    parityBit4++;
                }

                if (currSub.charAt(2) == '1') {
                    parityBit2++;
                    parityBit4++;
                }

                if (currSub.charAt(3) == '1') {
                    parityBit1++;
                    parityBit2++;
                    parityBit4++;
                }

                encodedPart =
                    (parityBit1 % 2 == 1? "1": "0") +
                        (parityBit2 % 2 == 1? "1": "0") +
                        currSub.charAt(0) +
                        (parityBit4 % 2 == 1? "1": "0") +
                        currSub.charAt(1) +
                        currSub.charAt(2) +
                        currSub.charAt(3) +
                        "0";

                encoded += encodedPart;
            }

            return encoded;
        }

        private CheckResult checkDifference(String output, String correct) {
            if (output.isEmpty() && correct.isEmpty()) return CheckResult.correct();

            if (output.length() != correct.length()) {
                return new CheckResult(false,
                    "The program was expected to output " +
                        correct.length() / 8 +
                        " bytes, but output " +
                        output.length() / 8);
            }

            for (int i = 0; i < output.length(); i += 8) {
                String currOutputByte = output.substring(i, i+8);
                String currCorrectByte = correct.substring(i, i+8);

                int difference = 0;
                for (int j = 0; j < currCorrectByte.length(); j++) {
                    char currOutputBit = currOutputByte.charAt(j);
                    char currCorrectBit = currCorrectByte.charAt(j);

                    if (currCorrectBit != currOutputBit) {
                        difference++;
                    }
                }

                if (difference == 0) {
                    return new CheckResult(false,
                        "One of bytes from the input stayed the same but should be changed");
                }

                if (difference != 1) {
                    return new CheckResult(false,
                        "One of bytes from the input was changes in more than one bit");
                }
            }

            return CheckResult.correct();
        }
    }

  learner_created: false
- name: src/correcter/send.txt
  visible: true
  text: Test
  learner_created: true
- name: src/correcter/encoded.txt
  visible: true
  text: "J??J\x1e?\x1e?"
  learner_created: true
- name: decoded.txt
  visible: true
  text: 5548172 6548 225147 23656595 5155
  learner_created: true
- name: encoded.txt
  visible: true
  text: "\x0fÌ3<3ÃðÃ\x0fð\0<\0Ãðÿ\x0fÃÃ3\0\0ðð\x0fÌ3<3\0ÿ\0\x0f\0\0<\x0f\0ð3\x0fÌ\
    3<\0ÃðÃ\x0fÌð3\0\0ð3\x0fÃð<<\0ðÌ\x0fÌÃ<3Ãÿ\x0f\x0fÌ33\0\0ðÌ\x0fÃ3<3ÃðÌ"
  learner_created: true
- name: src/correcter/received.txt
  visible: true
  learner_created: true
- name: src/correcter/decoded.txt
  visible: true
  learner_created: true
- name: src/correcter/NumberConverter.java
  visible: true
  text: |-
    //package correcter;
    //
    //import java.util.ArrayList;
    //import java.util.List;
    //
    //public class NumberConverter {
    //
    //    public String charToBinary(char ch) {
    //        StringBuilder sb = new StringBuilder();
    //        int num = ch;
    //        while (num > 0) {
    //            sb.append(num % 2);
    //            num /= 2;
    //        }
    //        //fill with leading zeros
    //        while (sb.length() < 8) {
    //            sb.append(0);
    //        }
    //        return sb.reverse().toString();
    //    }
    //
    //    public char binaryToChar(String num) {
    //        return (char) Integer.parseInt(num, 2);
    //    }
    //
    //    public String charToHex(char ch) {
    //        String digits = "0123456789ABCDEF";
    //        return "" + digits.charAt(ch / 16) + digits.charAt(ch % 16);
    //    }
    //
    //    public char hexToChar(String num) {
    //        return (char) Integer.parseInt(num, 16);
    //    }
    //
    //    public String binaryToHex(String num) {
    //        return charToHex(binaryToChar(num));
    //
    //    }
    //
    //    public String hexToBinary(String num) {
    //        return charToBinary(hexToChar(num));
    //    }
    //
    //    public String hexViewFromText(String text) {
    //        String[] hexArray = new String[text.length()];
    //        for (int i = 0; i < text.length(); i++) {
    //            hexArray[i] = charToHex(text.charAt(i));
    //        }
    //        return String.join(" ", hexArray);
    //    }
    //
    //    public String binViewFromHex(String text) {
    //        String[] hexArray = text.split(" ");
    //        String[] binArray = new String[hexArray.length];
    //        for (int i = 0; i < hexArray.length; i++) {
    //            binArray[i] = hexToBinary(hexArray[i]);
    //        }
    //        return String.join(" ", binArray);
    //    }
    //
    //    public String hexViewFromBinary(List<String> binaryList) {
    //        List<String> hexList = new ArrayList<>();
    //        for (String s : binaryList) {
    //            hexList.add(binaryToHex(s));
    //        }
    //        return String.join(" ", hexList);
    //    }
    //
    //    public String hexViewToText(String hexText) {
    //        String[] hexArray = hexText.split(" ");
    //        char[] charArray = new char[hexArray.length];
    //        for (int i = 0; i < hexArray.length; i++) {
    //            charArray[i] = hexToChar(hexArray[i]);
    //        }
    //        return String.valueOf(charArray);
    //    }
    //}
  learner_created: true
- name: src/correcter/Decoder.java
  visible: true
  text: |-
    //package correcter;
    //
    //import java.io.*;
    //import java.util.ArrayList;
    //import java.util.List;
    //import java.util.Random;
    //import java.util.Scanner;
    //
    //public class Decoder {
    //
    //    private final NumberConverter converter = new NumberConverter();
    //    private final Random rd = new Random();
    //
    //    private final File file1 = new File("send.txt");
    //    private final File file2 = new File("encoded.txt");
    //    private final File file3 = new File("received.txt");
    //    private final File file4 = new File("decoded.txt");
    //
    //    public void encode() {
    //        System.out.println("\n" + file1.getName() + ":");
    //        String text = readTextFromFile(file1);
    //        System.out.println("text view: " + text);
    //        String textHex = converter.hexViewFromText(text);
    //        System.out.println("hex view: " + textHex);
    //        String textBin = converter.binViewFromHex(textHex);
    //        System.out.println("bin view: " + textBin);
    //        System.out.println("\n" + file2.getName() + ":");
    //        List<String> expandedView = expand(textBin);
    //        System.out.println("expand: " + String.join(" ", expandedView));
    //        List<String> parityView = createParityView(expandedView);
    //        System.out.println("parity: " + String.join(" ", parityView));
    //        String hexView = converter.hexViewFromBinary(parityView);
    //        System.out.println("hex view: " + hexView);
    //        saveBytesToFile(hexView, file2);
    //    }
    //
    //    public void send() {
    //        System.out.println("\n" + file2.getName() + ":");
    //        String textHex = readBytesFromFile(file2);
    //        System.out.println("hex view: " + textHex);
    //        String textBin = converter.binViewFromHex(textHex);
    //        System.out.println("bin view: " + textBin);
    //        System.out.println("\n" + file3.getName() + ":");
    //        List<String> receivedTextBin = sendToReceiver(textBin);
    //        System.out.println("bin view: " + String.join(" ", receivedTextBin));
    //        String receivedTextHex = converter.hexViewFromBinary(receivedTextBin);
    //        System.out.println("hex view: " + receivedTextHex);
    //        saveBytesToFile(receivedTextHex, file3);
    //    }
    //
    //    public void decode() {
    //        System.out.println("\n" + file3.getName() + ":");
    //        String receivedTextHex = readBytesFromFile(file3);
    //        System.out.println("hex view: " + receivedTextHex);
    //        String receivedTextBin = converter.binViewFromHex(receivedTextHex);
    //        System.out.println("bin view: " + receivedTextBin);
    //        System.out.println("\n" + file4.getName() + ":");
    //        List<String> correctedTextBin = correctMsg(receivedTextBin);
    //        System.out.println("correct: " + String.join(" ", correctedTextBin));
    //        List<String> decodedTextBin = decodeBytes(correctedTextBin);
    //        System.out.println("decode: " + String.join(" ", decodedTextBin));
    //        List<String> decodedTextWithoutTail = removeTail(decodedTextBin);
    //        System.out.println("remove: " + String.join(" ", removeTail(decodedTextBin)));
    //        String decodedTextHex = converter.hexViewFromBinary(decodedTextWithoutTail);
    //        System.out.println("hex view: " + decodedTextHex);
    //        String decodedText = converter.hexViewToText(decodedTextHex);
    //        System.out.println("text view: " + decodedText);
    //        saveTextToFile(decodedText, file4);
    //    }
    //
    //    private String readTextFromFile(File file) {
    //        String text = "";
    //        try (Scanner sc = new Scanner(file)) {
    //            text = sc.nextLine().trim();
    //        } catch (FileNotFoundException e) {
    //            System.out.println("Error!. Failed to read from the file.");
    //        }
    //        return text;
    //    }
    //
    //    private String readBytesFromFile(File file) {
    //        List<String> hexArray = new ArrayList<>();
    //        try (FileInputStream fin = new FileInputStream(file)) {
    //            int i;
    //            while ((i = fin.read()) != -1) {
    //                hexArray.add(converter.charToHex((char) i));
    //            }
    //        } catch (IOException e) {
    //            System.out.println("Error!. Failed to read from the file.");
    //        }
    //        return String.join(" ", hexArray);
    //    }
    //
    //    private List<String> expand(String binaryView) {
    //        binaryView = binaryView.replace(" ", "");
    //        List<String> expandedList = new ArrayList<>();
    //        while (binaryView.length() > 3) {
    //            expandedList.add("" + binaryView.charAt(0) + binaryView.charAt(0)
    //                    + binaryView.charAt(1) + binaryView.charAt(1)
    //                    + binaryView.charAt(2) + binaryView.charAt(2)
    //                    + "..");
    //            binaryView = binaryView.substring(3);
    //        }
    //        StringBuilder lastElement = new StringBuilder();
    //        for (int i = 0; i < binaryView.length(); i++) {
    //            lastElement.append(binaryView.charAt(i)).append(binaryView.charAt(i));
    //        }
    //        lastElement.append(".".repeat(8 - 2 * binaryView.length()));
    //        expandedList.add(lastElement.toString());
    //        return expandedList;
    //    }
    //
    //    private List<String> createParityView(List<String> expandedView) {
    //        String lastElement = expandedView.get(expandedView.size() - 1).replace(".", "");
    //        lastElement = lastElement + "0".repeat(6 - lastElement.length()) + "..";
    //        expandedView.set(expandedView.size() - 1, lastElement);
    //        List<String> parityView = new ArrayList<>();
    //        for (String str : expandedView) {
    //            int sum = Integer.parseInt(str.charAt(0) + "")
    //                    + Integer.parseInt(str.charAt(2) + "")
    //                    + Integer.parseInt(str.charAt(4) + "");
    //            String newStr = str.substring(0, 6) + (sum % 2 == 0 ? "00" : "11");
    //            parityView.add(newStr);
    //        }
    //        return parityView;
    //    }
    //
    //    private void saveBytesToFile(String hexText, File file) {
    //        String[] hexArray = hexText.split(" ");
    //        try (FileOutputStream fout = new FileOutputStream(file)) {
    //            for (String s : hexArray) {
    //                fout.write(converter.hexToChar(s));
    //            }
    //        } catch (IOException e) {
    //            System.out.println("Error! Failed to save to the file.");
    //        }
    //    }
    //
    //    private void saveTextToFile(String str, File file) {
    //        try (FileWriter fw = new FileWriter(file)) {
    //            fw.write(str);
    //        } catch (IOException e) {
    //            System.out.println("Error! Failed to save to the file.");
    //        }
    //    }
    //
    //    private List<String> sendToReceiver(String binText) {
    //        List<String> encodedMsg = new ArrayList<>();
    //        String[] bytes = binText.split(" ");
    //        for (String str : bytes) {
    //            encodedMsg.add(injectBinaryNoise(str));
    //        }
    //        return encodedMsg;
    //    }
    //
    //    private String injectBinaryNoise(String num) {
    //        char[] bitChar = num.toCharArray();
    //        int index = rd.nextInt(bitChar.length);
    //        bitChar[index] = bitChar[index] == '0' ? '1' : '0';
    //        return String.valueOf(bitChar);
    //    }
    //
    //    private List<String> correctMsg(String text) {
    //        String[] bytes = text.split(" ");
    //        List<String> correctedBytes = new ArrayList<>();
    //        for (String element : bytes) {
    //            correctedBytes.add(removeNoise(element));
    //        }
    //        return correctedBytes;
    //    }
    //
    //    private String removeNoise(String binText) {
    //        char[] bitArray = binText.toCharArray();
    //        if (bitArray[6] != bitArray[7]) {
    //            int sum = Integer.parseInt(bitArray[0] + "")
    //                    + Integer.parseInt(bitArray[2] + "")
    //                    + Integer.parseInt(bitArray[4] + "");
    //            bitArray[6] = (sum % 2 == 0) ? '0' : '1';
    //            bitArray[7] = bitArray[6];
    //            return String.valueOf(bitArray);
    //        }
    //        int corruptedPair = 0;
    //        for (int i = 0; i < 6; i += 2) {
    //            if (bitArray[i] != bitArray[i + 1]) {
    //                corruptedPair = i / 2;
    //            }
    //        }
    //        int partialSum = 0;
    //        for (int i = 0; i < 3; i++) {
    //            if (i == corruptedPair) {
    //                continue;
    //            }
    //            partialSum += Integer.parseInt(bitArray[2 * i] + "");
    //        }
    //        char correctChar;
    //        if (partialSum % 2 == 0) {
    //            correctChar = bitArray[6];
    //        } else {
    //            correctChar = (bitArray[6] == '1') ? '0' : '1';
    //        }
    //        bitArray[2 *corruptedPair] = correctChar;
    //        bitArray[2 *corruptedPair + 1] = correctChar;
    //        return String.valueOf(bitArray);
    //    }
    //
    //    private List<String> decodeBytes(List<String> encodedText) {
    //        for (int i = 0; i < encodedText.size(); i++) {
    //            encodedText.set(i, encodedText.get(i).substring(0, 6));
    //        }
    //        String bitStream = String.join("", encodedText);
    //        StringBuilder sb = new StringBuilder();
    //        for (int i = 0; i < bitStream.length(); i += 2) {
    //            sb.append(bitStream.charAt(i));
    //        }
    //        bitStream = sb.toString();
    //
    //        List<String> decodedBytes = new ArrayList<>();
    //        StringBuilder nextByte = new StringBuilder();
    //        int length = bitStream.length();
    //        nextByte.append(bitStream.charAt(0));
    //        for (int i = 1; i < length; i++) {
    //            if (i % 8 == 0) {
    //                decodedBytes.add(nextByte.toString());
    //                nextByte = new StringBuilder();
    //            }
    //            nextByte.append(bitStream.charAt(i));
    //        }
    //        decodedBytes.add(nextByte.toString());
    //        return decodedBytes;
    //    }
    //
    //    private List<String> removeTail(List<String> bytes) {
    //        if (bytes.get(bytes.size() - 1).length() < 8) {
    //            bytes.remove(bytes.size() - 1);
    //        }
    //        return bytes;
    //    }
    //}
  learner_created: true
- name: received.txt
  visible: true
  text: "\nÜ1\x1c³ÓñÂ/ô\x04=\x02Áøû\x0eCË7\x02\x02øñ\x0eÄ\x13|;\b¿\x02\a\x04@8\a\x01\
    às\aÜ\x13|\x02ËñC\nLø7\x04 às\aCø,, ÐÍ\x1fìË|1Áß\x0e\x1fÜ##\x04\bñÄ\x1fÇ2>2Ç°Í"
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/5458#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Tue, 09 Aug 2022 20:02:27 UTC
record: -1
